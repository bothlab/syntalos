/*
 * Copyright (C) 2022 Matthias Klumpp <matthias@tenstral.net>
 *
 * Licensed under the GNU Lesser General Public License Version 3
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "crashreportdialog.h"
#include "ui_crashreportdialog.h"

#include <QtConcurrent/QtConcurrent>
#include <QFileDialog>
#include <QMessageBox>
#include <QStandardPaths>

#include "debugcollect.h"

static const int MAX_LOG_ENTRIES_IN_REPORT = 100;

CrashReportDialog::CrashReportDialog(ReportMode mode, QWidget *parent)
    : QDialog(parent),
      ui(new Ui::CrashReportDialog),
      m_mode(mode)
{
    ui->setupUi(this);
    ui->pageStack->setCurrentIndex(0);
    if (m_mode == ReportMode::DEBUG_FREEZE)
        setWindowTitle("Syntalos Freeze Debugger");
    else
        setWindowTitle("Syntalos Crash Info Collector");

    // set icon
    ui->doneIconLabel->setPixmap(QIcon::fromTheme(QStringLiteral("checkmark")).pixmap(64, 64));

    // check if all the tools we need are there
    m_allToolsFound = true;
    bool gdbFound = false;
    if (QStandardPaths::findExecutable("coredumpctl").isEmpty()) {
        ui->coredumpctlLabel->setText("Coredumpctl is missing!");
        ui->coredumpctlIconLabel->setPixmap(QIcon::fromTheme(QStringLiteral("emblem-error")).pixmap(20, 20));
        m_allToolsFound = false;
    } else {
        ui->coredumpctlLabel->setText("Coredumpctl found.");
        ui->coredumpctlIconLabel->setPixmap(QIcon::fromTheme(QStringLiteral("emblem-checked")).pixmap(20, 20));
    }
    if (QStandardPaths::findExecutable("gdb").isEmpty()) {
        ui->gdbLabel->setText("GDB is missing!");
        ui->gdbIconLabel->setPixmap(QIcon::fromTheme(QStringLiteral("emblem-error")).pixmap(20, 20));
        m_allToolsFound = false;
    } else {
        ui->gdbLabel->setText("GDB found.");
        ui->gdbIconLabel->setPixmap(QIcon::fromTheme(QStringLiteral("emblem-checked")).pixmap(20, 20));
        gdbFound = true;
    }
    ui->extraInfoWidget->setVisible(false);

    if (m_allToolsFound)
        ui->warnLabel->setVisible(false);
    else
        ui->warnLabel->setText("Some important tools were not found!\nThe generated report may be incomplete.");

    if (m_mode == ReportMode::DEBUG_FREEZE) {
        ui->headerLabel->setText("Syntalos Freeze Debugger");
        ui->introLabel->setText(QStringLiteral("<html><p>This tool will try to collect useful information about a <b>currently running</b> "
                                               "but unresponsive <i>Syntalos</i> instance.</p>"
                                               "<p>Information generated by this tool can then be shared with developers to investigate the issue.<br/>"
                                               "Note that the generated debug data may contain sensitive information!<br/>"
                                               "Please check the generated data before sending it to a potentially untrusted party.</p>"
                                               "<p>Please make sure Syntalos is <b>running</b> and also currently frozen before clicking the <i>Analyze</i> button!</p>"));
        ui->nextButton->setText("Analyze Now!");
        ui->nextButton->setIcon(QIcon::fromTheme("search"));

        if (!gdbFound) {
            // we can't do anything without GDB...
            ui->nextButton->setEnabled(false);
            ui->warnLabel->setText("We can not continue without the GNU Debugger (GDB).\nPlease install it and try again!");
        }

        // we need to attach to a running process, try to make sure that we are allowed to do so
        m_ptsMgr.ensureAllowed();
    }
}

CrashReportDialog::~CrashReportDialog()
{
    if (m_mode == ReportMode::DEBUG_FREEZE)
        m_ptsMgr.reset();

    delete ui;
}

void CrashReportDialog::on_closeButton_clicked()
{
    QApplication::quit();
}

static QString sliceJournalMessages(JournalCollector &journal)
{
    QString report;
    const auto msgEntries = journal.messageEntries();
    for (int i = 0; i < msgEntries.length(); i++) {
        const auto entry = msgEntries[i];
        report += QStringLiteral("%1 %2 [%3]: %4\n").arg(entry.time.toString(Qt::ISODate),
                                                         QString::number(entry.priority),
                                                         entry.unit,
                                                         entry.message);
    }
    if (msgEntries.length() > MAX_LOG_ENTRIES_IN_REPORT)
        report += QStringLiteral("\n- List truncated, included only the last %1 entries.\n").arg(MAX_LOG_ENTRIES_IN_REPORT);

    return report;
}

extern QPair<QString, QPair<bool, QDateTime>> generateCrashReport()
{
    QString report;
    JournalCollector journal;

    qDebug().noquote() << "Generating crash report.";
    report += QStringLiteral("# Syntalos Crash Report (generated: %1)\n\n").arg(QDateTime::currentDateTime().toString(Qt::ISODate));
    report += "### Log Messages\n";
    report += QStringLiteral("Boot: %1\n").arg(journal.currentBootId());

    qDebug().noquote() << "Finding Syntalos-related journal entries...";
    bool ret = journal.findMessageEntries("syntalos", MAX_LOG_ENTRIES_IN_REPORT);
    if (journal.messageEntries().isEmpty()) {
        if (ret)
            report += "- None found!\n";
        else
            report += journal.lastError();
    } else {
        report += "\n" + sliceJournalMessages(journal);
    }

    qDebug().noquote() << "Finding Syntalos coredump entries...";
    ret = journal.findCoredumpEntries("syntalos");
    const auto coredumpEntries = journal.coredumpEntries();
    report += "\n### Latest Crash Backtrace\n";
    auto coredumpTime = QDateTime::currentDateTime();
    bool haveCoredump = coredumpEntries.length() >= 1;
    if (haveCoredump) {
        const auto coredumpEntry = coredumpEntries.first();
        report += journal.generateBacktrace(coredumpEntry);
        coredumpTime = coredumpEntry.time;
    } else {
        if (ret)
            report += "- No recent crashes found!\n";
        else
            report += journal.lastError();
    }

    return qMakePair(report, qMakePair(haveCoredump, coredumpTime));
}

extern QString generateStallReport()
{
    QString report;

    qDebug().noquote() << "Generating stall report.";
    report += QStringLiteral("# Syntalos Stall Report (generated: %1)\n\n").arg(QDateTime::currentDateTime().toString(Qt::ISODate));

    bool processFound;
    const auto backtrace = generateBacktraceForRunningProcess("syntalos", &processFound);
    if (!processFound)
        return backtrace;

    JournalCollector journal;
    report += "### Log Messages\n";
    bool ret = journal.findMessageEntries("syntalos", MAX_LOG_ENTRIES_IN_REPORT);
    if (journal.messageEntries().isEmpty()) {
        if (ret)
            report += "- None found!\n";
        else
            report += journal.lastError();
    } else {
        report += "\n" + sliceJournalMessages(journal);
    }

    report += "\n### Backtrace\n";
    report += backtrace;

    return report;
}

void CrashReportDialog::runPastCrashCollect()
{
    ui->progressBar->setRange(0, 0);
    // TODO: Make use of QPromise when we can switch to Qt6 to display
    // a proper progress bar.
    QFuture<QPair<QString, QPair<bool, QDateTime>>> future = QtConcurrent::run(generateCrashReport);
    while (!future.isFinished())
        QApplication::processEvents();

    qDebug().noquote() << "Received crash report data.";
    const auto reportResult = future.result();
    m_lastMdReport = reportResult.first;

    ui->pageStack->setCurrentWidget(ui->pageResult);
    ui->nextButton->setText("Save Report");
    ui->nextButton->setIcon(QIcon::fromTheme("document-save-as"));
    ui->nextButton->setEnabled(true);
    ui->closeButton->setEnabled(true);

    ui->doneInfoLabel->setText(QStringLiteral("<html><p><b>All done!</b><br/>"
                                              "You can now save the generated report to disk for sharing. Click on <i>Save Report</i> to save it.</p>"));
    if (reportResult.second.first) {
        ui->doneInfoLabel->setText(ui->doneInfoLabel->text() +
                                   QStringLiteral("<p>The crash described in this report happened on: <b>%1</b></p>").arg(reportResult.second.second.toString()));
    } else {
        // we didn't actually find a crash!
        ui->doneInfoLabel->setText(ui->doneInfoLabel->text() +
                                   QStringLiteral("<p><b>No crash / coredump data was found!</b> The report only contains log data.</p>"));
    }
    if (!m_allToolsFound)
        ui->doneInfoLabel->setText(ui->doneInfoLabel->text() + QStringLiteral("<br/>"
                                                                              "Please keep in mind that this report may be <b>incomplete</b> "
                                                                              "due to missing analysis tools on this system."));
}

void CrashReportDialog::runFreezeDebug()
{
    ui->progressBar->setRange(0, 0);
    // TODO: Make use of QPromise when we can switch to Qt6 to display
    // a proper progress bar.
    QFuture<QString> future = QtConcurrent::run(generateStallReport);
    while (!future.isFinished())
        QApplication::processEvents();

    qDebug().noquote() << "Received stall report data.";
    m_lastMdReport = future.result();
    if (m_lastMdReport.startsWith("Error:")) {
        QMessageBox::warning(this, "Syntalos not found", "Unable to find a running Syntalos instance!");
        ui->pageStack->setCurrentWidget(ui->pageIntro);
        ui->nextButton->setEnabled(true);
        ui->closeButton->setEnabled(true);
        return;
    }

    ui->pageStack->setCurrentWidget(ui->pageResult);
    ui->nextButton->setText("Save Report");
    ui->nextButton->setIcon(QIcon::fromTheme("document-save-as"));
    ui->nextButton->setEnabled(true);
    ui->closeButton->setEnabled(true);

    ui->doneInfoLabel->setText(QStringLiteral("<html><b>All done!</b><br/>"
                                              "You can now save the generated report to disk for sharing. Click on <i>Save Report</i> to save it."));
    if (!m_allToolsFound)
        ui->doneInfoLabel->setText(ui->doneInfoLabel->text() + QStringLiteral("<br/>"
                                                                              "Please keep in mind that this report may be <b>incomplete</b> "
                                                                              "due to missing analysis tools on this system."));
}

void CrashReportDialog::on_nextButton_clicked()
{
    const auto currentPage = ui->pageStack->currentWidget();
    if (currentPage == ui->pageIntro) {
        // Switch from intro page to processing
        ui->pageStack->setCurrentWidget(ui->pageProcessing);
        ui->closeButton->setEnabled(false);
        ui->nextButton->setEnabled(false);

        if (m_mode == ReportMode::DEBUG_FREEZE)
            runFreezeDebug();
        else
            runPastCrashCollect();

        return;
    }

    if (currentPage == ui->pageResult) {
        // Switch from result page to saving data and exiting

        QString baseNamePrefix = QStringLiteral("SyntalosCrashReport");
        if (m_mode == ReportMode::DEBUG_FREEZE)
            baseNamePrefix = QStringLiteral("SyntalosFreezeReport");

        QString fileName;
        QString fnameSuggestion = QStringLiteral("%1_%2.md").arg(baseNamePrefix, QDateTime::currentDateTime().toString("yyddMM"));
        fileName = QFileDialog::getSaveFileName(this,
                                                "Select Report Filename",
                                                QStandardPaths::writableLocation(QStandardPaths::HomeLocation) + "/" + fnameSuggestion,
                                                "Text Files (*.md)");

        if (fileName.isEmpty())
            return;

        // save result
        QFile file(fileName);
        if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
            QMessageBox::warning(this, "Unable to save file", QStringLiteral("Failed to save file: %1").arg(file.errorString()));
            return;
        }

        QTextStream out(&file);
        out << m_lastMdReport << "\n";

        qDebug().noquote() << "Crash info saved:" << fileName;
        QApplication::quit();
    }
}
